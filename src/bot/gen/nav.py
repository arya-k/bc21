"""

Generates a GOTO with unrolled loops, of a specified size...

"""

# TODO: see if iteratively adding directions is better


NAV_GRID_SIZE = 5
NAV_ITERATIONS = 3

HALF_SIZE = NAV_GRID_SIZE // 2
DIRS = list(zip([0, 1, 1, 1, 0, -1, -1, -1], [1, 1, 0, -1, -1, -1, 0, 1]))
DIRNAMES = [
    "EAST",
    "NORTHEAST",
    "NORTH",
    "NORTHWEST",
    "WEST",
    "SOUTHWEST",
    "SOUTH",
    "SOUTHEAST",
]


def grid_locations():
    """ Generator to get all indices in the grid """
    for y in range(NAV_GRID_SIZE):
        for x in range(NAV_GRID_SIZE):
            yield y, x

def adjacent(y, x):
    """ Generator to get all neighbors within the bounds of the nav grid """
    for offset in DIRS:
        _x, _y = x + offset[0], y + offset[1]
        if 0 <= _x < NAV_GRID_SIZE and 0 <= _y < NAV_GRID_SIZE:
            yield _y, _x



code = f"""
private static Direction goTo{NAV_GRID_SIZE}(MapLocation target) throws GameActionException {{
    /* AUTOGENERATED with `nav.py`, with params NAV_GRID_SIZE={NAV_GRID_SIZE}, NAV_ITERATIONS={NAV_ITERATIONS} */

    RobotController rc_ = rc; // move into local scope
"""

# Initializing cost and movement costs.

code += """
    // POPULATE COSTS AND MOVEMENT COSTS"""

for i, (y, x) in enumerate(grid_locations()):
    code += """
    {init}tile = rc_.getLocation().translate({dx}, {dy});
    double cost_{y}_{x} = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
    double move_cost_{y}_{x} = Double.MAX_VALUE;
    if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
        cost_{y}_{x} = Double.MAX_VALUE;
    else
        move_cost_{y}_{x} = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);""".format(
        x=x, y=y, dy=y - HALF_SIZE, dx=x - HALF_SIZE, init="" if i else "MapLocation "
    )


# Iterative cost determination

code += """

    // ITERATIVELY DETERMINE COSTS
    for (int iter={}; --iter>=0;) {{
""".format(
    NAV_ITERATIONS
)

for y, x in grid_locations():
    neighbors = list(adjacent(y, x))

    min_expr = f"Math.min(cost_{neighbors[0][0]}_{neighbors[0][1]}, cost_{y}_{x} - move_cost_{y}_{x})"
    for adj_y, adj_x in neighbors[1:]:
        min_expr = f"Math.min(cost_{adj_y}_{adj_x}, {min_expr})"

    code += f"cost_{y}_{x} = {min_expr} + move_cost_{y}_{x};\n"
code += "}\n"


# minimum direction

code += """
    // DETERMINING MIN COST DIRECTION
    Direction ret = null;
    double minCost = Double.MAX_VALUE;
"""

for i, (name, offset) in enumerate(zip(DIRNAMES, DIRS)):
    costString = f"cost_{HALF_SIZE + offset[0]}_{HALF_SIZE + offset[1]}"
    minCostUpdate = f"minCost = {costString};" if i != 7 else ""

    code += f"""
    if ({costString} < minCost && {costString} < {1 << 30}) {{
        {minCostUpdate}
        ret = Direction.{name};
    }}"""

code += """
    return ret;
}"""

print(code)
