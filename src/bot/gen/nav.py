"""

Generates a GOTO with unrolled loops, of a specified size...

"""

# TODO: see if iteratively adding directions is better

NAV_GRID_SIZE = 7
NAV_ITERATIONS = 3

HALF_SIZE = NAV_GRID_SIZE // 2
DIRS = {
    "EAST": (0, 1),
    "NORTHEAST": (1, 1),
    "NORTH": (1, 0),
    "NORTHWEST": (1, -1),
    "WEST": (0, -1),
    "SOUTHWEST": (-1, -1),
    "SOUTH": (-1, 0),
    "SOUTHEAST": (-1, 1),
}


def grid_locations():
    """ Generator to get all indices in the grid """
    for y in range(NAV_GRID_SIZE):
        for x in range(NAV_GRID_SIZE):
            yield y, x


def adjacent(y, x):
    """ Generator to get all neighbors within the bounds of the nav grid """
    for dy, dx in DIRS.values():
        if 0 <= y + dy < NAV_GRID_SIZE and 0 <= x + dx < NAV_GRID_SIZE:
            yield y + dy, x + dx


code = f"""
private static Direction goTo{NAV_GRID_SIZE}(MapLocation target) throws GameActionException {{
    /* AUTOGENERATED with `nav.py`, with params NAV_GRID_SIZE={NAV_GRID_SIZE}, NAV_ITERATIONS={NAV_ITERATIONS} */

    RobotController rc_ = rc; // move into local scope
"""

# Initializing cost and movement costs.

code += """
    // POPULATE COSTS AND MOVEMENT COSTS"""

for i, (y, x) in enumerate(grid_locations()):
    code += """
    {init}tile = rc_.getLocation().translate({dx}, {dy});
    double cost_{y}_{x} = tile.distanceSquaredTo(target);
    double move_cost_{y}_{x} = Double.MAX_VALUE;
    if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
        cost_{y}_{x} = Double.MAX_VALUE;
    else
        move_cost_{y}_{x} = 1 / rc_.sensePassability(tile);""".format(
        x=x, y=y, dy=y - HALF_SIZE, dx=x - HALF_SIZE, init="" if i else "MapLocation "
    )


# Iterative cost determination

for iter in range(NAV_ITERATIONS):
    code += f"\n    // iteration {iter+1}\n"
    for y, x in grid_locations():
        # tighten the circle of updated grid items...
        if not (
            (iter <= y < NAV_GRID_SIZE - iter) and (iter <= x < NAV_GRID_SIZE - iter)
        ):
            continue
        neighbors = list(adjacent(y, x))
        min_expr = f"Math.min(cost_{neighbors[0][0]}_{neighbors[0][1]}, cost_{y}_{x} - move_cost_{y}_{x})"
        for adj_y, adj_x in neighbors[1:]:
            min_expr = f"Math.min(cost_{adj_y}_{adj_x}, {min_expr})"

        code += f"    cost_{y}_{x} = {min_expr} + move_cost_{y}_{x};\n"

# minimum direction

code += """
    // DETERMINING MIN COST DIRECTION
    Direction ret = Direction.CENTER;
    double minCost = Double.MAX_VALUE;
"""

for i, (name, (dx, dy)) in enumerate(DIRS.items()):
    costString = f"cost_{HALF_SIZE + dx}_{HALF_SIZE + dy}"
    minCostUpdate = f"minCost = {costString};\n        " if i != 7 else ""

    code += f"""
    if ({costString} < minCost) {{
        {minCostUpdate}ret = Direction.{name};
    }}"""

code += f"""
    return minCost > {1 << 30} ? Direction.CENTER : ret;
}}"""

print(code)
