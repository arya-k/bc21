package bot;

import battlecode.common.Direction;
import battlecode.common.GameActionException;
import battlecode.common.MapLocation;
import battlecode.common.RobotController;

public class Nav {
    // Constants:
    static int INITIAL_COST_MULTIPLIER = 10;
    static int PASSABILITY_SCALE_FACTOR = 10;

    // Variables:
    static RobotController rc;
    static MapLocation goalPos = null;

    public static void init(RobotController rc) {
        Nav.rc = rc;

        // TODO: initialize map edge predictions?
        // TODO: pathfinding grid for higher order calculations?
    }

    /**
     * Run at the start of onUpdate to update navigation variables,
     * like the location of map edges.
     *
     * @return whether a move was made.
     */
    static boolean tick() throws GameActionException {
        // TODO: higher level planning
        // TODO: check if we can see that the target is off the map
        // TODO: try more complex computation if we have more of a cool down?

//        System.out.println("start: " + rc.getRoundNum() + " - " + Clock.getBytecodeNum());
        Direction dir = goTo5(goalPos);
//        System.out.println("end: " + rc.getRoundNum() + " - " + Clock.getBytecodeNum());
        if (dir != null && rc.canMove(dir)) {
            rc.move(dir);
            return true;
        }
        return false;
    }

    static Direction goInDir(Direction dir) throws GameActionException{
        if (rc.onTheMap(rc.adjacentLocation(dir))) {
            Direction moveDir = goTo5(rc.getLocation().translate(5*dir.dx, 5*dir.dy));
            return moveDir;
        }
        return null;
    }

    /**
     * Sets the navigation goal
     *
     * @param goal the map location to aim to head towards.
     */
    static void setGoal(MapLocation goal) {
        goalPos = goal;
    }

    /**
     * Given the direction of the target, attempts to move towards
     * it using an iterative algorithm that approximates the best moves.
     * This will be unrolled / heavily optimized.
     *
     * @param target the location of the target that we are moving towards.
     * @return the direction to move in, null if this method fails.
     */
    private static Direction goTo5(MapLocation target) throws GameActionException {
        /* AUTOGENERATED with `nav.py`, with params NAV_GRID_SIZE=5, NAV_ITERATIONS=3 */

        RobotController rc_ = rc; // move into local scope

        // POPULATE COSTS AND MOVEMENT COSTS
        MapLocation tile = rc_.getLocation().translate(-2, -2);
        double cost_0_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_0 = Double.MAX_VALUE;
        else
            move_cost_0_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, -2);
        double cost_0_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_1 = Double.MAX_VALUE;
        else
            move_cost_0_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, -2);
        double cost_0_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_2 = Double.MAX_VALUE;
        else
            move_cost_0_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, -2);
        double cost_0_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_3 = Double.MAX_VALUE;
        else
            move_cost_0_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, -2);
        double cost_0_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_4 = Double.MAX_VALUE;
        else
            move_cost_0_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, -1);
        double cost_1_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_0 = Double.MAX_VALUE;
        else
            move_cost_1_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, -1);
        double cost_1_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_1 = Double.MAX_VALUE;
        else
            move_cost_1_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, -1);
        double cost_1_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_2 = Double.MAX_VALUE;
        else
            move_cost_1_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, -1);
        double cost_1_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_3 = Double.MAX_VALUE;
        else
            move_cost_1_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, -1);
        double cost_1_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_4 = Double.MAX_VALUE;
        else
            move_cost_1_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 0);
        double cost_2_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_0 = Double.MAX_VALUE;
        else
            move_cost_2_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 0);
        double cost_2_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_1 = Double.MAX_VALUE;
        else
            move_cost_2_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 0);
        double cost_2_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_2 = Double.MAX_VALUE;
        else
            move_cost_2_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 0);
        double cost_2_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_3 = Double.MAX_VALUE;
        else
            move_cost_2_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 0);
        double cost_2_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_4 = Double.MAX_VALUE;
        else
            move_cost_2_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 1);
        double cost_3_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_0 = Double.MAX_VALUE;
        else
            move_cost_3_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 1);
        double cost_3_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_1 = Double.MAX_VALUE;
        else
            move_cost_3_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 1);
        double cost_3_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_2 = Double.MAX_VALUE;
        else
            move_cost_3_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 1);
        double cost_3_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_3 = Double.MAX_VALUE;
        else
            move_cost_3_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 1);
        double cost_3_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_4 = Double.MAX_VALUE;
        else
            move_cost_3_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 2);
        double cost_4_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_0 = Double.MAX_VALUE;
        else
            move_cost_4_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 2);
        double cost_4_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_1 = Double.MAX_VALUE;
        else
            move_cost_4_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 2);
        double cost_4_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_2 = Double.MAX_VALUE;
        else
            move_cost_4_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 2);
        double cost_4_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_3 = Double.MAX_VALUE;
        else
            move_cost_4_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 2);
        double cost_4_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_4 = Double.MAX_VALUE;
        else
            move_cost_4_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);

        // ITERATIVELY DETERMINE COSTS
        for (int iter = 3; --iter >= 0; ) {
            cost_0_0 = Math.min(cost_1_0 + move_cost_0_0, cost_0_0);
            cost_0_0 = Math.min(cost_1_1 + move_cost_0_0, cost_0_0);
            cost_0_0 = Math.min(cost_0_1 + move_cost_0_0, cost_0_0);
            cost_0_1 = Math.min(cost_1_1 + move_cost_0_1, cost_0_1);
            cost_0_1 = Math.min(cost_1_2 + move_cost_0_1, cost_0_1);
            cost_0_1 = Math.min(cost_0_2 + move_cost_0_1, cost_0_1);
            cost_0_1 = Math.min(cost_0_0 + move_cost_0_1, cost_0_1);
            cost_0_1 = Math.min(cost_1_0 + move_cost_0_1, cost_0_1);
            cost_0_2 = Math.min(cost_1_2 + move_cost_0_2, cost_0_2);
            cost_0_2 = Math.min(cost_1_3 + move_cost_0_2, cost_0_2);
            cost_0_2 = Math.min(cost_0_3 + move_cost_0_2, cost_0_2);
            cost_0_2 = Math.min(cost_0_1 + move_cost_0_2, cost_0_2);
            cost_0_2 = Math.min(cost_1_1 + move_cost_0_2, cost_0_2);
            cost_0_3 = Math.min(cost_1_3 + move_cost_0_3, cost_0_3);
            cost_0_3 = Math.min(cost_1_4 + move_cost_0_3, cost_0_3);
            cost_0_3 = Math.min(cost_0_4 + move_cost_0_3, cost_0_3);
            cost_0_3 = Math.min(cost_0_2 + move_cost_0_3, cost_0_3);
            cost_0_3 = Math.min(cost_1_2 + move_cost_0_3, cost_0_3);
            cost_0_4 = Math.min(cost_1_4 + move_cost_0_4, cost_0_4);
            cost_0_4 = Math.min(cost_0_3 + move_cost_0_4, cost_0_4);
            cost_0_4 = Math.min(cost_1_3 + move_cost_0_4, cost_0_4);
            cost_1_0 = Math.min(cost_2_0 + move_cost_1_0, cost_1_0);
            cost_1_0 = Math.min(cost_2_1 + move_cost_1_0, cost_1_0);
            cost_1_0 = Math.min(cost_1_1 + move_cost_1_0, cost_1_0);
            cost_1_0 = Math.min(cost_0_1 + move_cost_1_0, cost_1_0);
            cost_1_0 = Math.min(cost_0_0 + move_cost_1_0, cost_1_0);
            cost_1_1 = Math.min(cost_2_1 + move_cost_1_1, cost_1_1);
            cost_1_1 = Math.min(cost_2_2 + move_cost_1_1, cost_1_1);
            cost_1_1 = Math.min(cost_1_2 + move_cost_1_1, cost_1_1);
            cost_1_1 = Math.min(cost_0_2 + move_cost_1_1, cost_1_1);
            cost_1_1 = Math.min(cost_0_1 + move_cost_1_1, cost_1_1);
            cost_1_1 = Math.min(cost_0_0 + move_cost_1_1, cost_1_1);
            cost_1_1 = Math.min(cost_1_0 + move_cost_1_1, cost_1_1);
            cost_1_1 = Math.min(cost_2_0 + move_cost_1_1, cost_1_1);
            cost_1_2 = Math.min(cost_2_2 + move_cost_1_2, cost_1_2);
            cost_1_2 = Math.min(cost_2_3 + move_cost_1_2, cost_1_2);
            cost_1_2 = Math.min(cost_1_3 + move_cost_1_2, cost_1_2);
            cost_1_2 = Math.min(cost_0_3 + move_cost_1_2, cost_1_2);
            cost_1_2 = Math.min(cost_0_2 + move_cost_1_2, cost_1_2);
            cost_1_2 = Math.min(cost_0_1 + move_cost_1_2, cost_1_2);
            cost_1_2 = Math.min(cost_1_1 + move_cost_1_2, cost_1_2);
            cost_1_2 = Math.min(cost_2_1 + move_cost_1_2, cost_1_2);
            cost_1_3 = Math.min(cost_2_3 + move_cost_1_3, cost_1_3);
            cost_1_3 = Math.min(cost_2_4 + move_cost_1_3, cost_1_3);
            cost_1_3 = Math.min(cost_1_4 + move_cost_1_3, cost_1_3);
            cost_1_3 = Math.min(cost_0_4 + move_cost_1_3, cost_1_3);
            cost_1_3 = Math.min(cost_0_3 + move_cost_1_3, cost_1_3);
            cost_1_3 = Math.min(cost_0_2 + move_cost_1_3, cost_1_3);
            cost_1_3 = Math.min(cost_1_2 + move_cost_1_3, cost_1_3);
            cost_1_3 = Math.min(cost_2_2 + move_cost_1_3, cost_1_3);
            cost_1_4 = Math.min(cost_2_4 + move_cost_1_4, cost_1_4);
            cost_1_4 = Math.min(cost_0_4 + move_cost_1_4, cost_1_4);
            cost_1_4 = Math.min(cost_0_3 + move_cost_1_4, cost_1_4);
            cost_1_4 = Math.min(cost_1_3 + move_cost_1_4, cost_1_4);
            cost_1_4 = Math.min(cost_2_3 + move_cost_1_4, cost_1_4);
            cost_2_0 = Math.min(cost_3_0 + move_cost_2_0, cost_2_0);
            cost_2_0 = Math.min(cost_3_1 + move_cost_2_0, cost_2_0);
            cost_2_0 = Math.min(cost_2_1 + move_cost_2_0, cost_2_0);
            cost_2_0 = Math.min(cost_1_1 + move_cost_2_0, cost_2_0);
            cost_2_0 = Math.min(cost_1_0 + move_cost_2_0, cost_2_0);
            cost_2_1 = Math.min(cost_3_1 + move_cost_2_1, cost_2_1);
            cost_2_1 = Math.min(cost_3_2 + move_cost_2_1, cost_2_1);
            cost_2_1 = Math.min(cost_2_2 + move_cost_2_1, cost_2_1);
            cost_2_1 = Math.min(cost_1_2 + move_cost_2_1, cost_2_1);
            cost_2_1 = Math.min(cost_1_1 + move_cost_2_1, cost_2_1);
            cost_2_1 = Math.min(cost_1_0 + move_cost_2_1, cost_2_1);
            cost_2_1 = Math.min(cost_2_0 + move_cost_2_1, cost_2_1);
            cost_2_1 = Math.min(cost_3_0 + move_cost_2_1, cost_2_1);
            cost_2_2 = Math.min(cost_3_2 + move_cost_2_2, cost_2_2);
            cost_2_2 = Math.min(cost_3_3 + move_cost_2_2, cost_2_2);
            cost_2_2 = Math.min(cost_2_3 + move_cost_2_2, cost_2_2);
            cost_2_2 = Math.min(cost_1_3 + move_cost_2_2, cost_2_2);
            cost_2_2 = Math.min(cost_1_2 + move_cost_2_2, cost_2_2);
            cost_2_2 = Math.min(cost_1_1 + move_cost_2_2, cost_2_2);
            cost_2_2 = Math.min(cost_2_1 + move_cost_2_2, cost_2_2);
            cost_2_2 = Math.min(cost_3_1 + move_cost_2_2, cost_2_2);
            cost_2_3 = Math.min(cost_3_3 + move_cost_2_3, cost_2_3);
            cost_2_3 = Math.min(cost_3_4 + move_cost_2_3, cost_2_3);
            cost_2_3 = Math.min(cost_2_4 + move_cost_2_3, cost_2_3);
            cost_2_3 = Math.min(cost_1_4 + move_cost_2_3, cost_2_3);
            cost_2_3 = Math.min(cost_1_3 + move_cost_2_3, cost_2_3);
            cost_2_3 = Math.min(cost_1_2 + move_cost_2_3, cost_2_3);
            cost_2_3 = Math.min(cost_2_2 + move_cost_2_3, cost_2_3);
            cost_2_3 = Math.min(cost_3_2 + move_cost_2_3, cost_2_3);
            cost_2_4 = Math.min(cost_3_4 + move_cost_2_4, cost_2_4);
            cost_2_4 = Math.min(cost_1_4 + move_cost_2_4, cost_2_4);
            cost_2_4 = Math.min(cost_1_3 + move_cost_2_4, cost_2_4);
            cost_2_4 = Math.min(cost_2_3 + move_cost_2_4, cost_2_4);
            cost_2_4 = Math.min(cost_3_3 + move_cost_2_4, cost_2_4);
            cost_3_0 = Math.min(cost_4_0 + move_cost_3_0, cost_3_0);
            cost_3_0 = Math.min(cost_4_1 + move_cost_3_0, cost_3_0);
            cost_3_0 = Math.min(cost_3_1 + move_cost_3_0, cost_3_0);
            cost_3_0 = Math.min(cost_2_1 + move_cost_3_0, cost_3_0);
            cost_3_0 = Math.min(cost_2_0 + move_cost_3_0, cost_3_0);
            cost_3_1 = Math.min(cost_4_1 + move_cost_3_1, cost_3_1);
            cost_3_1 = Math.min(cost_4_2 + move_cost_3_1, cost_3_1);
            cost_3_1 = Math.min(cost_3_2 + move_cost_3_1, cost_3_1);
            cost_3_1 = Math.min(cost_2_2 + move_cost_3_1, cost_3_1);
            cost_3_1 = Math.min(cost_2_1 + move_cost_3_1, cost_3_1);
            cost_3_1 = Math.min(cost_2_0 + move_cost_3_1, cost_3_1);
            cost_3_1 = Math.min(cost_3_0 + move_cost_3_1, cost_3_1);
            cost_3_1 = Math.min(cost_4_0 + move_cost_3_1, cost_3_1);
            cost_3_2 = Math.min(cost_4_2 + move_cost_3_2, cost_3_2);
            cost_3_2 = Math.min(cost_4_3 + move_cost_3_2, cost_3_2);
            cost_3_2 = Math.min(cost_3_3 + move_cost_3_2, cost_3_2);
            cost_3_2 = Math.min(cost_2_3 + move_cost_3_2, cost_3_2);
            cost_3_2 = Math.min(cost_2_2 + move_cost_3_2, cost_3_2);
            cost_3_2 = Math.min(cost_2_1 + move_cost_3_2, cost_3_2);
            cost_3_2 = Math.min(cost_3_1 + move_cost_3_2, cost_3_2);
            cost_3_2 = Math.min(cost_4_1 + move_cost_3_2, cost_3_2);
            cost_3_3 = Math.min(cost_4_3 + move_cost_3_3, cost_3_3);
            cost_3_3 = Math.min(cost_4_4 + move_cost_3_3, cost_3_3);
            cost_3_3 = Math.min(cost_3_4 + move_cost_3_3, cost_3_3);
            cost_3_3 = Math.min(cost_2_4 + move_cost_3_3, cost_3_3);
            cost_3_3 = Math.min(cost_2_3 + move_cost_3_3, cost_3_3);
            cost_3_3 = Math.min(cost_2_2 + move_cost_3_3, cost_3_3);
            cost_3_3 = Math.min(cost_3_2 + move_cost_3_3, cost_3_3);
            cost_3_3 = Math.min(cost_4_2 + move_cost_3_3, cost_3_3);
            cost_3_4 = Math.min(cost_4_4 + move_cost_3_4, cost_3_4);
            cost_3_4 = Math.min(cost_2_4 + move_cost_3_4, cost_3_4);
            cost_3_4 = Math.min(cost_2_3 + move_cost_3_4, cost_3_4);
            cost_3_4 = Math.min(cost_3_3 + move_cost_3_4, cost_3_4);
            cost_3_4 = Math.min(cost_4_3 + move_cost_3_4, cost_3_4);
            cost_4_0 = Math.min(cost_4_1 + move_cost_4_0, cost_4_0);
            cost_4_0 = Math.min(cost_3_1 + move_cost_4_0, cost_4_0);
            cost_4_0 = Math.min(cost_3_0 + move_cost_4_0, cost_4_0);
            cost_4_1 = Math.min(cost_4_2 + move_cost_4_1, cost_4_1);
            cost_4_1 = Math.min(cost_3_2 + move_cost_4_1, cost_4_1);
            cost_4_1 = Math.min(cost_3_1 + move_cost_4_1, cost_4_1);
            cost_4_1 = Math.min(cost_3_0 + move_cost_4_1, cost_4_1);
            cost_4_1 = Math.min(cost_4_0 + move_cost_4_1, cost_4_1);
            cost_4_2 = Math.min(cost_4_3 + move_cost_4_2, cost_4_2);
            cost_4_2 = Math.min(cost_3_3 + move_cost_4_2, cost_4_2);
            cost_4_2 = Math.min(cost_3_2 + move_cost_4_2, cost_4_2);
            cost_4_2 = Math.min(cost_3_1 + move_cost_4_2, cost_4_2);
            cost_4_2 = Math.min(cost_4_1 + move_cost_4_2, cost_4_2);
            cost_4_3 = Math.min(cost_4_4 + move_cost_4_3, cost_4_3);
            cost_4_3 = Math.min(cost_3_4 + move_cost_4_3, cost_4_3);
            cost_4_3 = Math.min(cost_3_3 + move_cost_4_3, cost_4_3);
            cost_4_3 = Math.min(cost_3_2 + move_cost_4_3, cost_4_3);
            cost_4_3 = Math.min(cost_4_2 + move_cost_4_3, cost_4_3);
            cost_4_4 = Math.min(cost_3_4 + move_cost_4_4, cost_4_4);
            cost_4_4 = Math.min(cost_3_3 + move_cost_4_4, cost_4_4);
            cost_4_4 = Math.min(cost_4_3 + move_cost_4_4, cost_4_4);
        }

        // DETERMINING MIN COST DIRECTION
        Direction ret = null;
        double minCost = Double.MAX_VALUE;

        if (cost_2_3 < minCost && cost_2_3 < 1 << 20) {
            minCost = cost_2_3;
            ret = Direction.EAST;
        }
        if (cost_3_3 < minCost && cost_3_3 < 1 << 20) {
            minCost = cost_3_3;
            ret = Direction.NORTHEAST;
        }
        if (cost_3_2 < minCost && cost_3_2 < 1 << 20) {
            minCost = cost_3_2;
            ret = Direction.NORTH;
        }
        if (cost_3_1 < minCost && cost_3_1 < 1 << 20) {
            minCost = cost_3_1;
            ret = Direction.NORTHWEST;
        }
        if (cost_2_1 < minCost && cost_2_1 < 1 << 20) {
            minCost = cost_2_1;
            ret = Direction.WEST;
        }
        if (cost_1_1 < minCost && cost_1_1 < 1 << 20) {
            minCost = cost_1_1;
            ret = Direction.SOUTHWEST;
        }
        if (cost_1_2 < minCost && cost_1_2 < 1 << 20) {
            minCost = cost_1_2;
            ret = Direction.SOUTH;
        }
        if (cost_1_3 < minCost && cost_1_3 < 1 << 20) {

            ret = Direction.SOUTHEAST;
        }
        return ret;
    }
}
