package bot;

import battlecode.common.*;

public class Nav {
    // Constants:
    static int INITIAL_COST_MULTIPLIER = 10;
    static int PASSABILITY_SCALE_FACTOR = 10;

    // Variables:
    static RobotController rc;
    static MapLocation goalPos = null;

    public static void init(RobotController rc) {
        Nav.rc = rc;

        // TODO: initialize map edge predictions?
        // TODO: pathfinding grid for higher order calculations?
    }

    /**
     * Run at the start of onUpdate to update navigation variables,
     * like the location of map edges.
     *
     * @return whether a move was made.
     */
    static boolean tick() throws GameActionException {
        // TODO: higher level planning
        // TODO: check if we can see that the target is off the map
        // TODO: try more complex computation if we have more of a cool down?

        int startRound = rc.getRoundNum();

        Direction dir = goTo5(goalPos);

        if (startRound != rc.getRoundNum()) {
            throw new GameActionException(GameActionExceptionType.INTERNAL_ERROR, "Navigation took more than 1 turn!");
        }

        if (dir != null && rc.canMove(dir)) {
            rc.move(dir);
            return true;
        }
        return false;
    }

    static Direction goInDir(Direction dir) throws GameActionException{
        if (rc.onTheMap(rc.adjacentLocation(dir))) {
            Direction moveDir = goTo5(rc.getLocation().translate(5*dir.dx, 5*dir.dy));
            return moveDir;
        }
        return null;
    }

    /**
     * Sets the navigation goal
     *
     * @param goal the map location to aim to head towards.
     */
    static void setGoal(MapLocation goal) {
        goalPos = goal;
    }


    /**
     * Given the direction of the target, attempts to move towards
     * it using an iterative algorithm that approximates the best moves.
     * This will be unrolled / heavily optimized.
     *
     * @param target the location of the target that we are moving towards.
     * @return the direction to move in, null if this method fails.
     */
    private static Direction goTo5(MapLocation target) throws GameActionException {
        /* AUTOGENERATED with `nav.py`, with params NAV_GRID_SIZE=5, NAV_ITERATIONS=2 */

        RobotController rc_ = rc; // move into local scope

        // POPULATE COSTS AND MOVEMENT COSTS
        MapLocation tile = rc_.getLocation().translate(-2, -2);
        double cost_0_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_0 = Double.MAX_VALUE;
        else
            move_cost_0_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, -2);
        double cost_0_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_1 = Double.MAX_VALUE;
        else
            move_cost_0_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, -2);
        double cost_0_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_2 = Double.MAX_VALUE;
        else
            move_cost_0_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, -2);
        double cost_0_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_3 = Double.MAX_VALUE;
        else
            move_cost_0_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, -2);
        double cost_0_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_4 = Double.MAX_VALUE;
        else
            move_cost_0_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, -1);
        double cost_1_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_0 = Double.MAX_VALUE;
        else
            move_cost_1_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, -1);
        double cost_1_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_1 = Double.MAX_VALUE;
        else
            move_cost_1_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, -1);
        double cost_1_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_2 = Double.MAX_VALUE;
        else
            move_cost_1_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, -1);
        double cost_1_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_3 = Double.MAX_VALUE;
        else
            move_cost_1_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, -1);
        double cost_1_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_4 = Double.MAX_VALUE;
        else
            move_cost_1_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 0);
        double cost_2_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_0 = Double.MAX_VALUE;
        else
            move_cost_2_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 0);
        double cost_2_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_1 = Double.MAX_VALUE;
        else
            move_cost_2_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 0);
        double cost_2_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_2 = Double.MAX_VALUE;
        else
            move_cost_2_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 0);
        double cost_2_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_3 = Double.MAX_VALUE;
        else
            move_cost_2_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 0);
        double cost_2_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_4 = Double.MAX_VALUE;
        else
            move_cost_2_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 1);
        double cost_3_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_0 = Double.MAX_VALUE;
        else
            move_cost_3_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 1);
        double cost_3_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_1 = Double.MAX_VALUE;
        else
            move_cost_3_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 1);
        double cost_3_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_2 = Double.MAX_VALUE;
        else
            move_cost_3_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 1);
        double cost_3_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_3 = Double.MAX_VALUE;
        else
            move_cost_3_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 1);
        double cost_3_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_4 = Double.MAX_VALUE;
        else
            move_cost_3_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 2);
        double cost_4_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_0 = Double.MAX_VALUE;
        else
            move_cost_4_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 2);
        double cost_4_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_1 = Double.MAX_VALUE;
        else
            move_cost_4_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 2);
        double cost_4_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_2 = Double.MAX_VALUE;
        else
            move_cost_4_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 2);
        double cost_4_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_3 = Double.MAX_VALUE;
        else
            move_cost_4_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 2);
        double cost_4_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_4 = Double.MAX_VALUE;
        else
            move_cost_4_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);

        // ITERATIVELY DETERMINE COSTS
        for (int iter = 2; --iter >= 0; ) {
            cost_0_0 = Math.min(cost_0_1, Math.min(cost_1_1, Math.min(cost_1_0, cost_0_0 - move_cost_0_0))) + move_cost_0_0;
            cost_0_1 = Math.min(cost_1_0, Math.min(cost_0_0, Math.min(cost_0_2, Math.min(cost_1_2, Math.min(cost_1_1, cost_0_1 - move_cost_0_1))))) + move_cost_0_1;
            cost_0_2 = Math.min(cost_1_1, Math.min(cost_0_1, Math.min(cost_0_3, Math.min(cost_1_3, Math.min(cost_1_2, cost_0_2 - move_cost_0_2))))) + move_cost_0_2;
            cost_0_3 = Math.min(cost_1_2, Math.min(cost_0_2, Math.min(cost_0_4, Math.min(cost_1_4, Math.min(cost_1_3, cost_0_3 - move_cost_0_3))))) + move_cost_0_3;
            cost_0_4 = Math.min(cost_1_3, Math.min(cost_0_3, Math.min(cost_1_4, cost_0_4 - move_cost_0_4))) + move_cost_0_4;
            cost_1_0 = Math.min(cost_0_0, Math.min(cost_0_1, Math.min(cost_1_1, Math.min(cost_2_1, Math.min(cost_2_0, cost_1_0 - move_cost_1_0))))) + move_cost_1_0;
            cost_1_1 = Math.min(cost_2_0, Math.min(cost_1_0, Math.min(cost_0_0, Math.min(cost_0_1, Math.min(cost_0_2, Math.min(cost_1_2, Math.min(cost_2_2, Math.min(cost_2_1, cost_1_1 - move_cost_1_1)))))))) + move_cost_1_1;
            cost_1_2 = Math.min(cost_2_1, Math.min(cost_1_1, Math.min(cost_0_1, Math.min(cost_0_2, Math.min(cost_0_3, Math.min(cost_1_3, Math.min(cost_2_3, Math.min(cost_2_2, cost_1_2 - move_cost_1_2)))))))) + move_cost_1_2;
            cost_1_3 = Math.min(cost_2_2, Math.min(cost_1_2, Math.min(cost_0_2, Math.min(cost_0_3, Math.min(cost_0_4, Math.min(cost_1_4, Math.min(cost_2_4, Math.min(cost_2_3, cost_1_3 - move_cost_1_3)))))))) + move_cost_1_3;
            cost_1_4 = Math.min(cost_2_3, Math.min(cost_1_3, Math.min(cost_0_3, Math.min(cost_0_4, Math.min(cost_2_4, cost_1_4 - move_cost_1_4))))) + move_cost_1_4;
            cost_2_0 = Math.min(cost_1_0, Math.min(cost_1_1, Math.min(cost_2_1, Math.min(cost_3_1, Math.min(cost_3_0, cost_2_0 - move_cost_2_0))))) + move_cost_2_0;
            cost_2_1 = Math.min(cost_3_0, Math.min(cost_2_0, Math.min(cost_1_0, Math.min(cost_1_1, Math.min(cost_1_2, Math.min(cost_2_2, Math.min(cost_3_2, Math.min(cost_3_1, cost_2_1 - move_cost_2_1)))))))) + move_cost_2_1;
            cost_2_2 = Math.min(cost_3_1, Math.min(cost_2_1, Math.min(cost_1_1, Math.min(cost_1_2, Math.min(cost_1_3, Math.min(cost_2_3, Math.min(cost_3_3, Math.min(cost_3_2, cost_2_2 - move_cost_2_2)))))))) + move_cost_2_2;
            cost_2_3 = Math.min(cost_3_2, Math.min(cost_2_2, Math.min(cost_1_2, Math.min(cost_1_3, Math.min(cost_1_4, Math.min(cost_2_4, Math.min(cost_3_4, Math.min(cost_3_3, cost_2_3 - move_cost_2_3)))))))) + move_cost_2_3;
            cost_2_4 = Math.min(cost_3_3, Math.min(cost_2_3, Math.min(cost_1_3, Math.min(cost_1_4, Math.min(cost_3_4, cost_2_4 - move_cost_2_4))))) + move_cost_2_4;
            cost_3_0 = Math.min(cost_2_0, Math.min(cost_2_1, Math.min(cost_3_1, Math.min(cost_4_1, Math.min(cost_4_0, cost_3_0 - move_cost_3_0))))) + move_cost_3_0;
            cost_3_1 = Math.min(cost_4_0, Math.min(cost_3_0, Math.min(cost_2_0, Math.min(cost_2_1, Math.min(cost_2_2, Math.min(cost_3_2, Math.min(cost_4_2, Math.min(cost_4_1, cost_3_1 - move_cost_3_1)))))))) + move_cost_3_1;
            cost_3_2 = Math.min(cost_4_1, Math.min(cost_3_1, Math.min(cost_2_1, Math.min(cost_2_2, Math.min(cost_2_3, Math.min(cost_3_3, Math.min(cost_4_3, Math.min(cost_4_2, cost_3_2 - move_cost_3_2)))))))) + move_cost_3_2;
            cost_3_3 = Math.min(cost_4_2, Math.min(cost_3_2, Math.min(cost_2_2, Math.min(cost_2_3, Math.min(cost_2_4, Math.min(cost_3_4, Math.min(cost_4_4, Math.min(cost_4_3, cost_3_3 - move_cost_3_3)))))))) + move_cost_3_3;
            cost_3_4 = Math.min(cost_4_3, Math.min(cost_3_3, Math.min(cost_2_3, Math.min(cost_2_4, Math.min(cost_4_4, cost_3_4 - move_cost_3_4))))) + move_cost_3_4;
            cost_4_0 = Math.min(cost_3_0, Math.min(cost_3_1, Math.min(cost_4_1, cost_4_0 - move_cost_4_0))) + move_cost_4_0;
            cost_4_1 = Math.min(cost_4_0, Math.min(cost_3_0, Math.min(cost_3_1, Math.min(cost_3_2, Math.min(cost_4_2, cost_4_1 - move_cost_4_1))))) + move_cost_4_1;
            cost_4_2 = Math.min(cost_4_1, Math.min(cost_3_1, Math.min(cost_3_2, Math.min(cost_3_3, Math.min(cost_4_3, cost_4_2 - move_cost_4_2))))) + move_cost_4_2;
            cost_4_3 = Math.min(cost_4_2, Math.min(cost_3_2, Math.min(cost_3_3, Math.min(cost_3_4, Math.min(cost_4_4, cost_4_3 - move_cost_4_3))))) + move_cost_4_3;
            cost_4_4 = Math.min(cost_4_3, Math.min(cost_3_3, Math.min(cost_3_4, cost_4_4 - move_cost_4_4))) + move_cost_4_4;
        }

        // DETERMINING MIN COST DIRECTION
        Direction ret = null;
        double minCost = Double.MAX_VALUE;

        if (cost_2_3 < minCost && cost_2_3 < 1073741824) {
            minCost = cost_2_3;
            ret = Direction.EAST;
        }
        if (cost_3_3 < minCost && cost_3_3 < 1073741824) {
            minCost = cost_3_3;
            ret = Direction.NORTHEAST;
        }
        if (cost_3_2 < minCost && cost_3_2 < 1073741824) {
            minCost = cost_3_2;
            ret = Direction.NORTH;
        }
        if (cost_3_1 < minCost && cost_3_1 < 1073741824) {
            minCost = cost_3_1;
            ret = Direction.NORTHWEST;
        }
        if (cost_2_1 < minCost && cost_2_1 < 1073741824) {
            minCost = cost_2_1;
            ret = Direction.WEST;
        }
        if (cost_1_1 < minCost && cost_1_1 < 1073741824) {
            minCost = cost_1_1;
            ret = Direction.SOUTHWEST;
        }
        if (cost_1_2 < minCost && cost_1_2 < 1073741824) {
            minCost = cost_1_2;
            ret = Direction.SOUTH;
        }
        if (cost_1_3 < minCost && cost_1_3 < 1073741824) {

            ret = Direction.SOUTHEAST;
        }
        return ret;
    }


    private static Direction goTo7(MapLocation target) throws GameActionException {
        /* AUTOGENERATED with `nav.py`, with params NAV_GRID_SIZE=7, NAV_ITERATIONS=3 */

        RobotController rc_ = rc; // move into local scope

        // POPULATE COSTS AND MOVEMENT COSTS
        MapLocation tile = rc_.getLocation().translate(-3, -3);
        double cost_0_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_0 = Double.MAX_VALUE;
        else
            move_cost_0_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, -3);
        double cost_0_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_1 = Double.MAX_VALUE;
        else
            move_cost_0_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, -3);
        double cost_0_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_2 = Double.MAX_VALUE;
        else
            move_cost_0_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, -3);
        double cost_0_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_3 = Double.MAX_VALUE;
        else
            move_cost_0_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, -3);
        double cost_0_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_4 = Double.MAX_VALUE;
        else
            move_cost_0_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, -3);
        double cost_0_5 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_5 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_5 = Double.MAX_VALUE;
        else
            move_cost_0_5 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(3, -3);
        double cost_0_6 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_0_6 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_0_6 = Double.MAX_VALUE;
        else
            move_cost_0_6 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-3, -2);
        double cost_1_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_0 = Double.MAX_VALUE;
        else
            move_cost_1_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, -2);
        double cost_1_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_1 = Double.MAX_VALUE;
        else
            move_cost_1_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, -2);
        double cost_1_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_2 = Double.MAX_VALUE;
        else
            move_cost_1_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, -2);
        double cost_1_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_3 = Double.MAX_VALUE;
        else
            move_cost_1_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, -2);
        double cost_1_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_4 = Double.MAX_VALUE;
        else
            move_cost_1_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, -2);
        double cost_1_5 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_5 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_5 = Double.MAX_VALUE;
        else
            move_cost_1_5 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(3, -2);
        double cost_1_6 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_1_6 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_1_6 = Double.MAX_VALUE;
        else
            move_cost_1_6 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-3, -1);
        double cost_2_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_0 = Double.MAX_VALUE;
        else
            move_cost_2_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, -1);
        double cost_2_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_1 = Double.MAX_VALUE;
        else
            move_cost_2_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, -1);
        double cost_2_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_2 = Double.MAX_VALUE;
        else
            move_cost_2_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, -1);
        double cost_2_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_3 = Double.MAX_VALUE;
        else
            move_cost_2_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, -1);
        double cost_2_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_4 = Double.MAX_VALUE;
        else
            move_cost_2_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, -1);
        double cost_2_5 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_5 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_5 = Double.MAX_VALUE;
        else
            move_cost_2_5 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(3, -1);
        double cost_2_6 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_2_6 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_2_6 = Double.MAX_VALUE;
        else
            move_cost_2_6 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-3, 0);
        double cost_3_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_0 = Double.MAX_VALUE;
        else
            move_cost_3_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 0);
        double cost_3_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_1 = Double.MAX_VALUE;
        else
            move_cost_3_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 0);
        double cost_3_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_2 = Double.MAX_VALUE;
        else
            move_cost_3_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 0);
        double cost_3_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_3 = Double.MAX_VALUE;
        else
            move_cost_3_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 0);
        double cost_3_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_4 = Double.MAX_VALUE;
        else
            move_cost_3_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 0);
        double cost_3_5 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_5 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_5 = Double.MAX_VALUE;
        else
            move_cost_3_5 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(3, 0);
        double cost_3_6 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_3_6 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_3_6 = Double.MAX_VALUE;
        else
            move_cost_3_6 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-3, 1);
        double cost_4_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_0 = Double.MAX_VALUE;
        else
            move_cost_4_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 1);
        double cost_4_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_1 = Double.MAX_VALUE;
        else
            move_cost_4_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 1);
        double cost_4_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_2 = Double.MAX_VALUE;
        else
            move_cost_4_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 1);
        double cost_4_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_3 = Double.MAX_VALUE;
        else
            move_cost_4_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 1);
        double cost_4_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_4 = Double.MAX_VALUE;
        else
            move_cost_4_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 1);
        double cost_4_5 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_5 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_5 = Double.MAX_VALUE;
        else
            move_cost_4_5 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(3, 1);
        double cost_4_6 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_4_6 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_4_6 = Double.MAX_VALUE;
        else
            move_cost_4_6 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-3, 2);
        double cost_5_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_5_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_5_0 = Double.MAX_VALUE;
        else
            move_cost_5_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 2);
        double cost_5_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_5_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_5_1 = Double.MAX_VALUE;
        else
            move_cost_5_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 2);
        double cost_5_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_5_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_5_2 = Double.MAX_VALUE;
        else
            move_cost_5_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 2);
        double cost_5_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_5_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_5_3 = Double.MAX_VALUE;
        else
            move_cost_5_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 2);
        double cost_5_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_5_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_5_4 = Double.MAX_VALUE;
        else
            move_cost_5_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 2);
        double cost_5_5 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_5_5 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_5_5 = Double.MAX_VALUE;
        else
            move_cost_5_5 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(3, 2);
        double cost_5_6 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_5_6 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_5_6 = Double.MAX_VALUE;
        else
            move_cost_5_6 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-3, 3);
        double cost_6_0 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_6_0 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_6_0 = Double.MAX_VALUE;
        else
            move_cost_6_0 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-2, 3);
        double cost_6_1 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_6_1 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_6_1 = Double.MAX_VALUE;
        else
            move_cost_6_1 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(-1, 3);
        double cost_6_2 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_6_2 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_6_2 = Double.MAX_VALUE;
        else
            move_cost_6_2 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(0, 3);
        double cost_6_3 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_6_3 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_6_3 = Double.MAX_VALUE;
        else
            move_cost_6_3 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(1, 3);
        double cost_6_4 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_6_4 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_6_4 = Double.MAX_VALUE;
        else
            move_cost_6_4 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(2, 3);
        double cost_6_5 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_6_5 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_6_5 = Double.MAX_VALUE;
        else
            move_cost_6_5 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);
        tile = rc_.getLocation().translate(3, 3);
        double cost_6_6 = tile.distanceSquaredTo(target) * INITIAL_COST_MULTIPLIER;
        double move_cost_6_6 = Double.MAX_VALUE;
        if (!rc_.onTheMap(tile) || rc_.isLocationOccupied(tile))
            cost_6_6 = Double.MAX_VALUE;
        else
            move_cost_6_6 = PASSABILITY_SCALE_FACTOR / rc_.sensePassability(tile);

        // ITERATIVELY DETERMINE COSTS
        for (int iter = 3; --iter >= 0; ) {
            cost_0_0 = Math.min(cost_0_1, Math.min(cost_1_1, Math.min(cost_1_0, cost_0_0 - move_cost_0_0))) + move_cost_0_0;
            cost_0_1 = Math.min(cost_1_0, Math.min(cost_0_0, Math.min(cost_0_2, Math.min(cost_1_2, Math.min(cost_1_1, cost_0_1 - move_cost_0_1))))) + move_cost_0_1;
            cost_0_2 = Math.min(cost_1_1, Math.min(cost_0_1, Math.min(cost_0_3, Math.min(cost_1_3, Math.min(cost_1_2, cost_0_2 - move_cost_0_2))))) + move_cost_0_2;
            cost_0_3 = Math.min(cost_1_2, Math.min(cost_0_2, Math.min(cost_0_4, Math.min(cost_1_4, Math.min(cost_1_3, cost_0_3 - move_cost_0_3))))) + move_cost_0_3;
            cost_0_4 = Math.min(cost_1_3, Math.min(cost_0_3, Math.min(cost_0_5, Math.min(cost_1_5, Math.min(cost_1_4, cost_0_4 - move_cost_0_4))))) + move_cost_0_4;
            cost_0_5 = Math.min(cost_1_4, Math.min(cost_0_4, Math.min(cost_0_6, Math.min(cost_1_6, Math.min(cost_1_5, cost_0_5 - move_cost_0_5))))) + move_cost_0_5;
            cost_0_6 = Math.min(cost_1_5, Math.min(cost_0_5, Math.min(cost_1_6, cost_0_6 - move_cost_0_6))) + move_cost_0_6;
            cost_1_0 = Math.min(cost_0_0, Math.min(cost_0_1, Math.min(cost_1_1, Math.min(cost_2_1, Math.min(cost_2_0, cost_1_0 - move_cost_1_0))))) + move_cost_1_0;
            cost_1_1 = Math.min(cost_2_0, Math.min(cost_1_0, Math.min(cost_0_0, Math.min(cost_0_1, Math.min(cost_0_2, Math.min(cost_1_2, Math.min(cost_2_2, Math.min(cost_2_1, cost_1_1 - move_cost_1_1)))))))) + move_cost_1_1;
            cost_1_2 = Math.min(cost_2_1, Math.min(cost_1_1, Math.min(cost_0_1, Math.min(cost_0_2, Math.min(cost_0_3, Math.min(cost_1_3, Math.min(cost_2_3, Math.min(cost_2_2, cost_1_2 - move_cost_1_2)))))))) + move_cost_1_2;
            cost_1_3 = Math.min(cost_2_2, Math.min(cost_1_2, Math.min(cost_0_2, Math.min(cost_0_3, Math.min(cost_0_4, Math.min(cost_1_4, Math.min(cost_2_4, Math.min(cost_2_3, cost_1_3 - move_cost_1_3)))))))) + move_cost_1_3;
            cost_1_4 = Math.min(cost_2_3, Math.min(cost_1_3, Math.min(cost_0_3, Math.min(cost_0_4, Math.min(cost_0_5, Math.min(cost_1_5, Math.min(cost_2_5, Math.min(cost_2_4, cost_1_4 - move_cost_1_4)))))))) + move_cost_1_4;
            cost_1_5 = Math.min(cost_2_4, Math.min(cost_1_4, Math.min(cost_0_4, Math.min(cost_0_5, Math.min(cost_0_6, Math.min(cost_1_6, Math.min(cost_2_6, Math.min(cost_2_5, cost_1_5 - move_cost_1_5)))))))) + move_cost_1_5;
            cost_1_6 = Math.min(cost_2_5, Math.min(cost_1_5, Math.min(cost_0_5, Math.min(cost_0_6, Math.min(cost_2_6, cost_1_6 - move_cost_1_6))))) + move_cost_1_6;
            cost_2_0 = Math.min(cost_1_0, Math.min(cost_1_1, Math.min(cost_2_1, Math.min(cost_3_1, Math.min(cost_3_0, cost_2_0 - move_cost_2_0))))) + move_cost_2_0;
            cost_2_1 = Math.min(cost_3_0, Math.min(cost_2_0, Math.min(cost_1_0, Math.min(cost_1_1, Math.min(cost_1_2, Math.min(cost_2_2, Math.min(cost_3_2, Math.min(cost_3_1, cost_2_1 - move_cost_2_1)))))))) + move_cost_2_1;
            cost_2_2 = Math.min(cost_3_1, Math.min(cost_2_1, Math.min(cost_1_1, Math.min(cost_1_2, Math.min(cost_1_3, Math.min(cost_2_3, Math.min(cost_3_3, Math.min(cost_3_2, cost_2_2 - move_cost_2_2)))))))) + move_cost_2_2;
            cost_2_3 = Math.min(cost_3_2, Math.min(cost_2_2, Math.min(cost_1_2, Math.min(cost_1_3, Math.min(cost_1_4, Math.min(cost_2_4, Math.min(cost_3_4, Math.min(cost_3_3, cost_2_3 - move_cost_2_3)))))))) + move_cost_2_3;
            cost_2_4 = Math.min(cost_3_3, Math.min(cost_2_3, Math.min(cost_1_3, Math.min(cost_1_4, Math.min(cost_1_5, Math.min(cost_2_5, Math.min(cost_3_5, Math.min(cost_3_4, cost_2_4 - move_cost_2_4)))))))) + move_cost_2_4;
            cost_2_5 = Math.min(cost_3_4, Math.min(cost_2_4, Math.min(cost_1_4, Math.min(cost_1_5, Math.min(cost_1_6, Math.min(cost_2_6, Math.min(cost_3_6, Math.min(cost_3_5, cost_2_5 - move_cost_2_5)))))))) + move_cost_2_5;
            cost_2_6 = Math.min(cost_3_5, Math.min(cost_2_5, Math.min(cost_1_5, Math.min(cost_1_6, Math.min(cost_3_6, cost_2_6 - move_cost_2_6))))) + move_cost_2_6;
            cost_3_0 = Math.min(cost_2_0, Math.min(cost_2_1, Math.min(cost_3_1, Math.min(cost_4_1, Math.min(cost_4_0, cost_3_0 - move_cost_3_0))))) + move_cost_3_0;
            cost_3_1 = Math.min(cost_4_0, Math.min(cost_3_0, Math.min(cost_2_0, Math.min(cost_2_1, Math.min(cost_2_2, Math.min(cost_3_2, Math.min(cost_4_2, Math.min(cost_4_1, cost_3_1 - move_cost_3_1)))))))) + move_cost_3_1;
            cost_3_2 = Math.min(cost_4_1, Math.min(cost_3_1, Math.min(cost_2_1, Math.min(cost_2_2, Math.min(cost_2_3, Math.min(cost_3_3, Math.min(cost_4_3, Math.min(cost_4_2, cost_3_2 - move_cost_3_2)))))))) + move_cost_3_2;
            cost_3_3 = Math.min(cost_4_2, Math.min(cost_3_2, Math.min(cost_2_2, Math.min(cost_2_3, Math.min(cost_2_4, Math.min(cost_3_4, Math.min(cost_4_4, Math.min(cost_4_3, cost_3_3 - move_cost_3_3)))))))) + move_cost_3_3;
            cost_3_4 = Math.min(cost_4_3, Math.min(cost_3_3, Math.min(cost_2_3, Math.min(cost_2_4, Math.min(cost_2_5, Math.min(cost_3_5, Math.min(cost_4_5, Math.min(cost_4_4, cost_3_4 - move_cost_3_4)))))))) + move_cost_3_4;
            cost_3_5 = Math.min(cost_4_4, Math.min(cost_3_4, Math.min(cost_2_4, Math.min(cost_2_5, Math.min(cost_2_6, Math.min(cost_3_6, Math.min(cost_4_6, Math.min(cost_4_5, cost_3_5 - move_cost_3_5)))))))) + move_cost_3_5;
            cost_3_6 = Math.min(cost_4_5, Math.min(cost_3_5, Math.min(cost_2_5, Math.min(cost_2_6, Math.min(cost_4_6, cost_3_6 - move_cost_3_6))))) + move_cost_3_6;
            cost_4_0 = Math.min(cost_3_0, Math.min(cost_3_1, Math.min(cost_4_1, Math.min(cost_5_1, Math.min(cost_5_0, cost_4_0 - move_cost_4_0))))) + move_cost_4_0;
            cost_4_1 = Math.min(cost_5_0, Math.min(cost_4_0, Math.min(cost_3_0, Math.min(cost_3_1, Math.min(cost_3_2, Math.min(cost_4_2, Math.min(cost_5_2, Math.min(cost_5_1, cost_4_1 - move_cost_4_1)))))))) + move_cost_4_1;
            cost_4_2 = Math.min(cost_5_1, Math.min(cost_4_1, Math.min(cost_3_1, Math.min(cost_3_2, Math.min(cost_3_3, Math.min(cost_4_3, Math.min(cost_5_3, Math.min(cost_5_2, cost_4_2 - move_cost_4_2)))))))) + move_cost_4_2;
            cost_4_3 = Math.min(cost_5_2, Math.min(cost_4_2, Math.min(cost_3_2, Math.min(cost_3_3, Math.min(cost_3_4, Math.min(cost_4_4, Math.min(cost_5_4, Math.min(cost_5_3, cost_4_3 - move_cost_4_3)))))))) + move_cost_4_3;
            cost_4_4 = Math.min(cost_5_3, Math.min(cost_4_3, Math.min(cost_3_3, Math.min(cost_3_4, Math.min(cost_3_5, Math.min(cost_4_5, Math.min(cost_5_5, Math.min(cost_5_4, cost_4_4 - move_cost_4_4)))))))) + move_cost_4_4;
            cost_4_5 = Math.min(cost_5_4, Math.min(cost_4_4, Math.min(cost_3_4, Math.min(cost_3_5, Math.min(cost_3_6, Math.min(cost_4_6, Math.min(cost_5_6, Math.min(cost_5_5, cost_4_5 - move_cost_4_5)))))))) + move_cost_4_5;
            cost_4_6 = Math.min(cost_5_5, Math.min(cost_4_5, Math.min(cost_3_5, Math.min(cost_3_6, Math.min(cost_5_6, cost_4_6 - move_cost_4_6))))) + move_cost_4_6;
            cost_5_0 = Math.min(cost_4_0, Math.min(cost_4_1, Math.min(cost_5_1, Math.min(cost_6_1, Math.min(cost_6_0, cost_5_0 - move_cost_5_0))))) + move_cost_5_0;
            cost_5_1 = Math.min(cost_6_0, Math.min(cost_5_0, Math.min(cost_4_0, Math.min(cost_4_1, Math.min(cost_4_2, Math.min(cost_5_2, Math.min(cost_6_2, Math.min(cost_6_1, cost_5_1 - move_cost_5_1)))))))) + move_cost_5_1;
            cost_5_2 = Math.min(cost_6_1, Math.min(cost_5_1, Math.min(cost_4_1, Math.min(cost_4_2, Math.min(cost_4_3, Math.min(cost_5_3, Math.min(cost_6_3, Math.min(cost_6_2, cost_5_2 - move_cost_5_2)))))))) + move_cost_5_2;
            cost_5_3 = Math.min(cost_6_2, Math.min(cost_5_2, Math.min(cost_4_2, Math.min(cost_4_3, Math.min(cost_4_4, Math.min(cost_5_4, Math.min(cost_6_4, Math.min(cost_6_3, cost_5_3 - move_cost_5_3)))))))) + move_cost_5_3;
            cost_5_4 = Math.min(cost_6_3, Math.min(cost_5_3, Math.min(cost_4_3, Math.min(cost_4_4, Math.min(cost_4_5, Math.min(cost_5_5, Math.min(cost_6_5, Math.min(cost_6_4, cost_5_4 - move_cost_5_4)))))))) + move_cost_5_4;
            cost_5_5 = Math.min(cost_6_4, Math.min(cost_5_4, Math.min(cost_4_4, Math.min(cost_4_5, Math.min(cost_4_6, Math.min(cost_5_6, Math.min(cost_6_6, Math.min(cost_6_5, cost_5_5 - move_cost_5_5)))))))) + move_cost_5_5;
            cost_5_6 = Math.min(cost_6_5, Math.min(cost_5_5, Math.min(cost_4_5, Math.min(cost_4_6, Math.min(cost_6_6, cost_5_6 - move_cost_5_6))))) + move_cost_5_6;
            cost_6_0 = Math.min(cost_5_0, Math.min(cost_5_1, Math.min(cost_6_1, cost_6_0 - move_cost_6_0))) + move_cost_6_0;
            cost_6_1 = Math.min(cost_6_0, Math.min(cost_5_0, Math.min(cost_5_1, Math.min(cost_5_2, Math.min(cost_6_2, cost_6_1 - move_cost_6_1))))) + move_cost_6_1;
            cost_6_2 = Math.min(cost_6_1, Math.min(cost_5_1, Math.min(cost_5_2, Math.min(cost_5_3, Math.min(cost_6_3, cost_6_2 - move_cost_6_2))))) + move_cost_6_2;
            cost_6_3 = Math.min(cost_6_2, Math.min(cost_5_2, Math.min(cost_5_3, Math.min(cost_5_4, Math.min(cost_6_4, cost_6_3 - move_cost_6_3))))) + move_cost_6_3;
            cost_6_4 = Math.min(cost_6_3, Math.min(cost_5_3, Math.min(cost_5_4, Math.min(cost_5_5, Math.min(cost_6_5, cost_6_4 - move_cost_6_4))))) + move_cost_6_4;
            cost_6_5 = Math.min(cost_6_4, Math.min(cost_5_4, Math.min(cost_5_5, Math.min(cost_5_6, Math.min(cost_6_6, cost_6_5 - move_cost_6_5))))) + move_cost_6_5;
            cost_6_6 = Math.min(cost_6_5, Math.min(cost_5_5, Math.min(cost_5_6, cost_6_6 - move_cost_6_6))) + move_cost_6_6;
        }

        // DETERMINING MIN COST DIRECTION
        Direction ret = null;
        double minCost = Double.MAX_VALUE;

        if (cost_3_4 < minCost && cost_3_4 < 1073741824) {
            minCost = cost_3_4;
            ret = Direction.EAST;
        }
        if (cost_4_4 < minCost && cost_4_4 < 1073741824) {
            minCost = cost_4_4;
            ret = Direction.NORTHEAST;
        }
        if (cost_4_3 < minCost && cost_4_3 < 1073741824) {
            minCost = cost_4_3;
            ret = Direction.NORTH;
        }
        if (cost_4_2 < minCost && cost_4_2 < 1073741824) {
            minCost = cost_4_2;
            ret = Direction.NORTHWEST;
        }
        if (cost_3_2 < minCost && cost_3_2 < 1073741824) {
            minCost = cost_3_2;
            ret = Direction.WEST;
        }
        if (cost_2_2 < minCost && cost_2_2 < 1073741824) {
            minCost = cost_2_2;
            ret = Direction.SOUTHWEST;
        }
        if (cost_2_3 < minCost && cost_2_3 < 1073741824) {
            minCost = cost_2_3;
            ret = Direction.SOUTH;
        }
        if (cost_2_4 < minCost && cost_2_4 < 1073741824) {

            ret = Direction.SOUTHEAST;
        }
        return ret;
    }
}
